<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Modernes Statemanagement f√ºr React</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>Modernes Statemanagement f√ºr React</b>
          </h2>
          <h3>
            <a
              href="https://www.web-developer-conference.de/programm/#/talk/modernes-statemanagement-fur-react"
              >Web Developer Conference, 28. April 2021 | DevSession</a
            >
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: react-training/2021_04_19_typescript_state.html</span
              >
            </p>
          </div>
        </section>

        <!--


Zustandsmanagement kann schnell zu einer echten Herausforderung werden, gerade in gr√∂√üeren React-Anwendungen. 

Denn Daten sollen ja zuverl√§ssig und schnell in den Komponenten zur Verf√ºgung stehen, die sie ben√∂tigen, 
ohne dass es etwa zu Inkonsistenzen kommt. Und auch der Code sollte verst√§ndlich und testbar bleiben. 
In dieser DevSession sehen wir uns einige M√∂glichkeiten "zeitgem√§√üen" Zustandsmanagements an. Als Grundlage nutzen wir die React-eigenen Mittel zum Statemanagement, 
die sich mit der Hooks und Context API umsetzen lassen. 

Au√üerdem stelle ich externe Bibliotheken f√ºrs Statemanagement vor wie Redux/Redux Toolkit und MobX. Wir sehen uns deren wichtigste Konzepte an und ordnen ein, 
f√ºr welche Anwendungen und Use-Cases sie jeweils am besten geeignet sind. 

Das ganze nat√ºrlich anhand vieler Code-Beispiele, um einen Eindruck der praktischen Umsetzung dieser Ans√§tze zu erhalten.

        -->

        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zeitplan 

            * 09:00-10:15
            * ca. 10:15-10:30 Pause üçù 
            * 10:30-11:45
            * ca. 11:45-12:00 Pause
            * 12:00-13:00 

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Beteiligt Euch gerne 

            * Ihr k√∂nnt jederzeit Fragen stellen, kommentieren, Feedback geben etc.
            * Ich versuche, zwischendurch immer wieder Live Coding zu machen
              * Dadurch sind wir flexibel und nicht an eine feste Slide-Reihenfolge gebunden
              * Au√üerdem f√ºr Euch (hoffentlich) spannender als Slide-Watching
            * Beteiligung per Chat oder Audio
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Agenda</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zum Einstieg...

            * Was sind Eure Vorkenntnisse?
            * Was verbindet ihr mit Statemanagement? Was m√∂chtet ihr heute lernen?
            * Bitte √∂ffnet [Mentimeter](https://www.menti.com) und gebt dort den Code ein (Chat!)
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Agenda

            * **Prio 1: Eure Fragen, Probleme und W√ºnsche** 

            * State Grundlagen (Wiederholung)
            * Arbeiten mit komplexem State
            * React Context API f√ºr globalen State
            * Redux f√ºr externen State

            * (Unterschiedliche React-Versionen) 
            * (Router)
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
    ## "The Art of State"
    
    ### Meine Artikelserie bei heise developer zum Thema

    * [Teil 1: Zustandsmanagement in React-Anwendungen](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendungen-4934595.html)
    * [Teil 2: React Context API und Redux ](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendung-Teil-2-4990188.html)
    * [Teil 3: Weitere Bibliotheken](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendung-Teil-3-5054351.html)

  </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
            ## State... ein paar Basics

            * Wor√ºber man sich Gedanken machen kann/sollte
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Verschiende Arten von State 1

            ### "Reichweite"
            * Lokaler State: Zustand, der nur von einer (logischen) Komponente ben√∂tigt wird
            * Globaler State: wird von der ganzen Anwendung oder gro√üen Teilen verwendet
            * Es gibt nat√ºrlich Abstufungen (Regionaler State? ü§î)

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Was ist global, was ist lokal?

            * üëâ Ich zeige euch eine Anwendung, und wir sch√§tzen ein, was globaler und was lokaler Zustand sein k√∂nnte
            * üëâ es gibt kein "richtig" oder "falsch"
            * Beispiel 1: PostEditor
            * Beispiel 2: angemeldeter Benutzer
            * Beispiel 3: Sortierreihenfolge
            * Beispiel 4: Einzelner Blogpost

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Wo wird Zustand gehalten?

            * Lokal oder global in der Komponentenhierarchie (React, Recoil)
            * Global au√üerhalb der Komponentenhierarchie (Redux, MobX)
            * In der URL üò≥
              * Was in die URL kommt ist eine **fachliche**, keine **technische** Frage
              * Welche Informationen m√∂chte ich verlinkbar haben? Aktuellen Blog-Post? Sortierreihenfolge?
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Verschiende Arten von State 2

            ### Struktur von lokalem Zustand
            * "Einfacher" Zustand: mehrere useState-Aufrufe in einer Komponente
            * "Komplexer" Zustand: *ein* State, der ein Objekt enth√§lt
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Objekten</h3>

          <ul>
            <li class="fragment">Zustand in React ist grunds√§tzlich immutable</li>

            <li class="fragment">
              Objekte (oder Arrays) im Zustand m√ºsst ihr also kopieren und dann die Kopie bearbeiten
            </li>

            <li class="fragment">Das gilt sowohl f√ºr useState, useReducer, Redux, ...</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            function BlogPost() {
              const [person, setPerson] = React.useState({});

              function handlePersonChange(newCity) {
                // verboten!
                person.address.city = newCity;

                // ü§®
                setPerson(person);
              }

            }
          </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        // Objekt-Spread-Operator zum Kopieren und ver√§ndern

        const newObject = {
          ...oldObject, // altes Objekt hier "einf√ºgen"
          updatedProperty: "new value" // (ausgew√§hlte) Werte in NEUEM Objekt ver√§ndern
        }
                    </code></pre>
          <h3 class="fragment">Object-Spread-Operator kopiert nur "flach"</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// Beispiel mit Verschachtelung:
const oldPerson = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };                      

const newPerson = {
  ...oldPerson, // altes Objekt hier "einf√ºgen"

  // address muss nun auch kopiert werden:
  address: { ...newPerson.address, city: "Hamburg" } 
}
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <pre class="fragment"><code class="javascript">
        // Spread-Operator bei Arrays

        const oldArray = [ "b", "c" ];

        // Anf√ºgen eines Elementes
        const newArray = [
          "a",  // vorne anf√ºgen
          ...oldArray, // hier altes Array reinkopieren
          "c" // hinten anf√ºgen
        ]

      </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <h3 class="fragment">Ver√§ndern von Objekten in Arrays</h3>

          <pre class="fragment"><code class="javascript">
        // Ver√§ndern von Arrays:

        const newArray = oldArray.map(oldEntry => {
          if (oldEntry.id === "user-1") { // dieses Element soll ver√§ndert werden
            return { ...oldEntry, name: "Klaus" }
          }
          return oldEntry; // unver√§ndert
        });

        // newArray ist eine Kopie, mit ggf. ver√§nderten Eintr√§gen
      </code></pre>

          <h3 class="fragment">Eintr√§ge aus Arrays entfernen</h3>

          <pre class="fragment"><code class="javascript">
        const newArray = oldArray.filter(oldEntry => oldEntry.id === idToBeRemoved);

        // newArray ist eine Kopie ohne die rausgefilterten Eintraege
        
      </code></pre>
        </section>

        <section>
          <h3>Arbeiten mit immutable Objekten (ES6)</h3>

          <h3 class="fragment">üò± üò∞ üò®</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Immer f√ºr Arbeiten mit unver√§nderlichen Datenstrukturen

          <img src="slides/images/immer.png" /> 

          * [ImmerJs](https://immerjs.github.io/immer/docs/introduction): _Create the next immutable state tree by simply modifying the current tree_
          * Konzept: altes Objekt wird in eine Funktion gesteckt, die daraus ein _Draft_ erzeugt
          * Das _Draft_ wird mit regul√§ren JavaScript APIs ver√§ndert, als wenn es mutable w√§re
          * Immer zeichnet die √Ñnderungen auf
          * Zum Schluss werden die √Ñnderungen auf eine Kopie des alten Objektes angewendet

        </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Immer: produce-Funktion</h3>

          <p>
            Die <b>produce</b>-Funktion bekommt ein Objekt √ºbergeben, sowie eine zweite Funktion,
            die von immer mit einem Draft aufgerufen wird.
          </p>
          <p>Dieses Draft kann ver√§ndert werden</p>
          <p>
            Der R√ºckgabe-Typ der produce-Funktion ist dann eine Kopie des alten Objektes mit den
            √Ñnderungen, die auf dem Draft vorgenommen wurden.
          </p>

          <pre class="fragment"><code class="javascript">
              import produce from "immer";

              const person = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };

              const newPerson = produce(person, draft => {
                person.name = "Susi";
                person.address.city = "Hamburg";
              })

              newPerson; // Neues Objekt!
              newPerson.name; // Susi
              newPerson.address // Neues Objekt!
              newPerson.address.city; // Hamburg
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer mit useState</h3>

          <pre class="fragment"><code class="javascript">
            function PersonEditor() {
              const [person, setPerson] = React.useState({});
  
              function handlePersonChange(newCity) {
                const newPerson = produce(person, draft => {
                  // draft kann ver√§ndert werden, als ob es ein mutable Objekt sei
                  // und zwar auf allen Ebenen des Objekt-Graphen
                  person.address.city = newCity;
                })
  
                // üòä
                setPerson(newPerson);
              }
            }
              
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer mit useImmer</h3>

          <ul>
            <li class="fragment">
              <a href="https://github.com/immerjs/use-immer">useImmer</a> kann als Ersatz f√ºr
              useState verwendet werden
            </li>

            <li class="fragment">
              Statt einer set-Funktion wird eine update-Funktion zur√ºckgeliefert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function PersonEditor() {
              // useImmer statt useState
              const [person, updatePerson] = useImmer({});
  
              function handlePersonChange(newCity) {
                // updatePerson liefert ein draft f√ºr den aktuellen Zustand
                // und setzt den draft dann als neuen Zustand
                updatePerson(draft => person.address.city = newCity)
              }
            }
          </code></pre>
        </section>

        <!-- <section>
          <h3>N√§chster Schritt</h3>
          <h2>Zustand "verteilen"</h2>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### Erinnerung:

    * **Zustand** wird von Parent-Komponenten nach unten gereicht (√ºber **Properties**)
    * Die Unterkomponenten k√∂nnen den Zustand darstellen (oder andere Dinge davon ableiten), aber ihn nicht **ver√§ndern**
    * (Unterkomponenten k√∂nnen zus√§tzlich eigenen Zustand haben)
    * Oberkomponenten k√∂nnen au√üerdem Callback-Funktionen an ihre Unterkomponenten √ºbergeben
    * √úber die Callback-Funktionen k√∂nnen Unterkomponenten den Oberkomponenten Ereignisse schicken
    * Die Oberkomponente kann auf das Ereignis z.B. mit einer State-√Ñnderung reagieren, so dass Ober- und Unterkomponente neu gerendert werden
    * Das Durchreichen von State- und Callbacks ist √ºber mehr als eine Ebene erlaubt (und gew√∂hnlich)

    <img class="fragment" style="height:600px" src="slides/images/state/datenfluss.svg" />
  </textarea
          >
        </section>

        <section>
          <h3>Beispiel</h3>
          <pre class="fragment"><code class="javascript">
    function App() {
      const [user, setUser] = React.useState(...);

      function handleFullNameChange(newFullName: string) { setUser(...) }

      return &lt;...>
        &lt;TextInput label="Full Name" value={user.fullName} 
           onTextChange={handleFullNameChange} />
      &lt;...>
    }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          // kein eigener State!
          function TextInput(props) {
            return &lt;...>
              &lt;input value={props.value}
                 onChange={e => props.onTextChange(e.target.value)} />
            &lt;...>
          }
              </code></pre>
        </section> -->

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung von komplexem Zustand

        ## Reducer-Funktionen und useReducer-Hook
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung und √Ñnderung von Zustand

        * Wir halten den Zustand lokal in einer Komponente
        * S√§mtliche √Ñnderungen daran passieren innerhalb der Komponente
        * Mit einer **reducer-Funktion** kann die Verwaltung des Zustandes aus der Komponente herausgel√∂st werden
          * (Der Zustand geh√∂rt aber weiterhin der Komponente)
        * Dadurch zum Beispiel besser testbar (Reducer sind pure Funktionen, normaler Unit-Test gen√ºgt)
        * Wiederverwendbar (keine Abh√§ngigkeit auf React)
        * Trennung UI/Logik, k√∂nnte zu √ºbersichtlicherem Code f√ºhren 
      </textarea
          >
        </section>

        <section>
          <h3>useReducer-Hook</h3>
          <p>Hintergrund: Eine reducer-Funktion...</p>
          <ul>
            <li class="fragment">
              ...erh√§lt einen (vorherigen) Zustand und eine Action als Parameter √ºbergeben
            </li>
            <li class="fragment">
              <b>Actions</b> sind anwendungsspezifische, beliebige JavaScript-Objekte
            </li>
            <li class="fragment">...verarbeitet die Action</li>
            <li class="fragment">...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li class="fragment">...muss Seiteneffekt frei sein ("pure function")</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
          reducer(old_state, action) => new_state
        </code></pre>

          <p class="fragment">
            <em
              >Reducer sind zentrales Konzept von Redux, kommen aber auch in anderen Bereichen vor
              (z.B. <code>Array.reduce</code>)</em
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3 class="todo">
            Evtl Beispiel: Shopping Cart Liste kann per reducer verwaltet werden, dann auch Test
            zeigen
          </h3>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Actions</h3>
          <ul>
            <li class="fragment">Pure JavaScript-Objekte</li>
            <li class="fragment">Haben √ºblicherweise <b>type</b> und <b>payload</b></li>
            <li class="fragment">√úber das <b>type</b>-Property k√∂nnen sie identifiziert werden</li>
            <li class="fragment">Der <b>Payload</b> enth√§lt Action-spezifische Daten</li>
          </ul>

          <pre class="fragment"><code class="javascript">
        const apiRequestStartedAction = {
          type: "requestStarted"; // kein Payload erforderlich
        }

        const apiRequestFinishedAction = {
          type: "requesFinished",
          dataReceived: data  // Action-spezifischer Payload (hier: geladene Daten)
        }
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion</h3>
          <ul>
            <li class="fragment">
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li class="fragment">
              Zustand ist immutable! Kann mit <code>immer</code> kombiniert werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function apiReducer(state, action) {
  switch (action.type) {
    case "requestStarted": {
      // vorherigen Zustand teilweise √ºbernehmen
      return { ...state, status: "loading" };
    }

    case "requestFinished": {
      // komplett neuen Zustand zur√ºckliefern
      return { status: "finished", data: action.dataReceived };
    }

    return state; // alle anderen Actions: Zustand unver√§ndert zur√ºck
  }
}            
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useReducer-Hook</h3>
          <ul>
            <li class="fragment">
              Mit dem <b>useReducer</b>-Hook wird die reducer-Funktion in der Komponente registriert
            </li>
            <li class="fragment">
              Der Hook bekommt die reducer-Funktion √ºbergeben und den initialen Zustand (√§hnlich wie
              useState)
            </li>
            <li class="fragment">
              Der Hook liefert ein Array zur√ºck mit zwei Eintr√§gen: dem aktuellen Zustand und der
              <b>dispatch</b>-Funktion. Auch hier √§hnlich wie bei useState: Zustand und Funktion zum
              √Ñndern des Zustandes
            </li>
            <li class="fragment">
              Mit der dispatch-Funktion k√∂nnen Actions an den Reducer gesendet werden
            </li>
            <li class="fragment">
              Der reducer aktualisiert verarbeitet die Action, liefert neuen Zustand zur√ºck,
              Komponente wird neu gerendert (wie bei useState)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
        function App() {
          const [apiState, dispatch] = React.useReducer(apiReducer, { status: "loading" });

          function loadData() {
            dispatch({ type: "requestStarted "});
            // ...Daten laden...
            dispatch({ type: "requestFinished", dataReceived: "..."});
          }

          // ...

        }
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
        ### N√§chster Schritt: Globaler Zustand

        * Man kann Zustand in **lokalen Zustand** und **globalen Zustand** einteilen
        * **Lokaler Zustand** ist Zustand, der "mehr oder weniger" einer Komponente zur Verf√ºgung steht
        * **Globlaer Zustand** hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon zust√§ndig
        * Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition

        * Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
        * Es spricht nichts dagegen, globalen Zustand, mit useState/useReducer zu verwalten, aber...
        * Du musst ihn unter Umst√§nden weit nach unten reichen
        * oder andersrum: er muss sehr weit oben aufgeh√§ngt sein, um z.B. f√ºr verschiedene Ansichten zur Verf√ºgung zu stehen, oder Ansichtswechsel zu "√ºberleben"
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### React Context

        * Der **React Context** ist eine M√∂glichkeit, globalen Zustand Komponenten zur Verf√ºgung zu stellen, ohne ihn √ºber Properties durchreichen zu m√ºssen
        * Es gibt dabei eine **Provider** Komponente, die ein beliebiges Objekt, den Kontext, allen unterhalb liegenden Komponenten zur Verf√ºgung stellt
        * Das Objekt kann Daten und (Callback-)Funktionen enthalten
        * Das Prinzip ist √§hnlich wie wir es schon gesehen haben, nur dass diese Daten nicht explizit per Properties von einer Ebene zur n√§chsten weitergerreicht werden m√ºssen.
        Stattdessen findet das Durchreichen transparent statt
        * Du kannst beliebig viele Kontexte in deiner Anwendung verwenden. Dann hast Du entsprechend mehr Provider-Komponenten.
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel</h3>
          <p>üëâ examples/context/ CounterContext und App implementieren!</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Factory</h3>
          <ul>
            <li class="fragment">Der Provider stellt ein beliebiges Objekt zur Verf√ºgung</li>
            <li class="fragment">
              Daf√ºr muss ein Context-Objekt mit <code>React.createContext</code> erzeugt werden.
              Dieses Objekt enth√§lt die Provider- und die Consumer-Komponente
            </li>
            <li class="fragment">(Consumer-Komponente ist mit Hooks API irrelevant)</li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        import react from "React";

        const ThemeContext = React.createContext();

        // erzeugt:
        // ThemeContext.Provider 
        // ThemeContext.Consumer (irrelevant mit Hooks API)
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Provider</h3>
          <ul>
            <li class="fragment">
              Die mit <code>createContext</code> erzeugte Provider Komponente erh√§lt ein Objekt als
              Properties, das sie allen unterhalb liegenden Komponenten (<code>children</code>) zur
              Verf√ºgung stellt.
            </li>
            <li class="fragment">Die Verwendung ist wie eine "normale" Komponente</li>
            <li class="fragment">
              √úblicherweise baut man sich eine Komponente darum, die dann auch die Daten h√§lt, die
              √ºber den Context zur Verf√ºgung gestellt werden sollen
            </li>
            <li class="fragment">Auch hierbei handelt es sich um eine "normale" Komponente:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        const ThemeContext = React.createContext();

        function ThemeContextProvider(props) {
          const [themeName, setThemeName] = React.useState();


          return &lt;ThemeContext.Provider value={{
            currentTheme: themeName,
            setCurrentTheme: setThemeName 
          }}>
          {props.children}
        &lt;/AuthContext.Provider>;
      }
</code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Context: Consumer</h3>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <ul>
            <li class="fragment">
              In allen Komponenten unterhalb der Provider Komponente, kann mit
              <code>useContext</code> auf das bereitgestellte Objekt zugegriffen werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function TextInput() {
const { themeName } = React.useContext(ThemeContext);

return &lt;div className={`theme-${themeName}`}>&lt;input ... />&lt;/div>
}            
    </code></pre>
          <p class="fragment">
            Wenn der Kontext sich √§ndert, werden alle Konsumer automatisch neu gerendert
          </p>
          <pre class="fragment"><code class="javascript">
function ThemeChooser() {
  const { setThemeName } = React.useContext(themeContext);
  return &lt;div>
    &lt;button onClick={() => setThemeName("dark")}>Dark Theme&lt;/button>
    &lt;button onClick={() => setThemeName("light")}>Light Theme&lt;/button>
    &lt;/div>
}                
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hook f√ºr Context-Zugriff</h3>

          <ul>
            <li class="fragment">
              Du kannst einen Custom Hook f√ºr den Zugriff auf deinen Kontext bauen
            </li>
            <li class="fragment">
              Dann ist die Technologie (Context) gekapselt und Du hast eine "fachliche" API
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            export function useTheme() {
              return React.useContext(ThemeContext);
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            function TextInput(props) {
              const { themeName } = useTheme();
              
              // ...
            }
          </code></pre>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Externes Statemanagement

            * **Externes** Statemanagement bedeutet, dass der Zustand aus deinen Komponenten herauswandert
            * Wird haben das exemplarisch bereits bei `useReducer` gesehen
            * Mit externem Statemanagement wird in der Regel **globaler Zustand** verwaltet
            * Es gibt mehrere Bibliotheken, die beiden bekanntesten sind:
              * [Redux](https://redux.js.org/)
              * [MobX](https://mobx.js.org/README.html)
            * Beide sind zun√§chst React-unabh√§ngig und f√ºr mehrere Webframeworks verf√ºgbar
            * D.h. die Logik, die Du damit entwickelst kannst Du prinzipiell auch mit anderen Webframeworks nutzen
            * Weitere Vertreter: [Recoil](https://recoiljs.org/) ebenfalls von Facebook, [OvermindJS](https://overmindjs.org/), von Codesandbox
              * Hier eher globales, aber nicht unbedingt **externes** Statemanagement
          </textarea>
        </section>

        <section>
          <h2>Beispiel: Redux</h2>
          <p>Anwendung: üëâ 20_redux/2-redux_complete</p>
        </section>

        <section>
          <h3>Wiederholung</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px" />
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px" />
        </section>

        <section>
          <h2>Redux im Code</h2>
          <p>üëâ 2-redux-workspace (PostEditor und post-slice)</p>
        </section>

        <section>
          <h2>Strukturierter √úberblick √ºber alle Redux Teile</h2>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Konzepte

            * **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
            * **Actions**: Einfache JavaScript-Objekte, die beschreiben was in einer Anwendung passiert. Bestehen aus einem Type und einem fachlichen Payload.
            * **Reducer**-Funktionen: Funktionen, in denen die Logik zur Verarbeitung des Zustands untergebracht ist. Sie erhalten eine Action und einen (alten) Zustand, verarbeiten die Action und liefern neuen Zustand zur√ºck.
            * **Action Creator**: Factory-Funktionen, die Action Objekte erzeugen
          </textarea>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Actions</h3>
          <ul>
            <li class="fragment">
              Pure JavaScript-Objekte, die eine Aktion in der Anwendung beschreiben
            </li>
            <li class="fragment">Haben √ºblicherweise <b>type</b> und <b>payload</b></li>
            <li class="fragment">√úber das <b>type</b>-Property k√∂nnen sie identifiziert werden</li>
            <li class="fragment">Der <b>Payload</b> enth√§lt Action-spezifische Daten</li>
          </ul>

          <pre class="fragment"><code class="javascript">
  clearDraftAction = {
    type: "editor/clearDraft"; // kein Payload erforderlich
  }

  setDraftTitleAction = {
    type: "editor/setDraftTtiel",
    newTitle: "..."  // Action-spezifischer Payload (hier: der neue Blog-Titel)
  }
</code></pre>
        </section>
        <section>
          <h3>Reducer-Funktion #1</h3>
          <ul>
            <li class="fragment">
              ...erh√§lt einen (vorherigen) Zustand und eine <em>Action</em> als Parameter √ºbergeben
            </li>
            <li class="fragment">...verarbeitet die Action</li>
            <li class="fragment">...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li class="fragment">...muss Seiteneffekt frei sein ("pure function")</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
          reducer(old_state, action) => new_state
        </code></pre>

          <p class="fragment">
            <em>In React mit useReducer (ohne Redux) einsetzbar</em>
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion #2</h3>
          <ul>
            <li class="fragment">
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li class="fragment">
              Zustand ist immutable! Kann mit der
              <a href="https://github.com/immerjs/immer">Bibliothek "immer"</a> kombiniert werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function editorReducer(state = initalDraftPost, action) {
              switch (action.type) {
                case "editor/clearDraft":
                  return initalDraftPost;
                case "editor/setDraftBody":
                  return { ...state, body: action.body };
                case "editor/setDraftTitle":
                  return { ...state, title: action.title };
                default:
                  return state;
              }
            }
      </code></pre>
        </section>

        <section>
          <h3>Redux: Store, Reducer und Actions</h3>
          <ul>
            <li class="fragment">
              Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen
              verwaltet
            </li>
            <li class="fragment">
              Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die
              reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des
              gloablen Zustands zugreifen. Ein Teil-Zustand wird auch als "Slice" bezeichnet (also
              ein Anwendungsteil)
            </li>
            <li class="fragment">
              Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so
              etwas wie eine Tabelle
            </li>
            <li class="fragment">
              Die reducer werden beim Starten der Anwendung in Redux registriert
            </li>
            <li class="fragment">
              Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine
              Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
              Anwendungsteile k√∂nnen darauf reagieren
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions ausl√∂sen</h3>
          <ul>
            <li class="fragment">Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li class="fragment">
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function PostEditor() {
              const dispatch = useDispatch();

              function handleTitleChange(newTitle) {
                dispatch({ type: "editor/setDraftTitle", title });
              }

              // ...

              &lt;input onChange={(e) => handleTitleChange(e.target.value) />
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Action Creator...</h3>
          <ul>
            <li class="fragment">...sind "Factory-Funktionen", die Action-Objekte erzeugen</li>
            <li class="fragment">...sind optional, werden aber nahezu immer verwendet</li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function setDraftTitle(newTitle) {
              return { 
                type: "editor/setDraftTitle", 
                title 
              };
            }
            }
          </code></pre>

          <p class="fragment">ü§î Wof√ºr k√∂nnten Action Creator sinnvoll sein?</p>
          <ul>
            <li class="fragment">Stellen sicher, dass Objekte korrekt aussehen</li>
            <li class="fragment">Verbergen interne Struktur der Actions vor der Anwendung</li>
            <li class="fragment">K√∂nnen plausibilit√§tspr√ºfungen machen</li>
            <li class="fragment">
              K√∂nnen Daten konvertieren, bevor sie in die Action √ºbernommen werden
            </li>
          </ul>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li class="fragment">
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li class="fragment">
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li class="fragment">
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li class="fragment">
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li class="fragment">Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li class="fragment">
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li class="fragment">
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
              function PostEditor() {
                const draftTitle = useSelector(state => state.editor.draftTitle);

                //  ...
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useSelector - Details</h3>
          <ul>
            <li class="fragment">
              Um festzustellen, ob sich die ausgew√§hlten Daten ver√§ndert haben, pr√ºft Redux auf
              <b>Identit√§t</b>!
            </li>
            <li class="fragment">
              Es wird deshalb empfohlen, nur einzelne Werte (keine Objekte) aus dem Store
              auszuw√§hlen - stattdessen mehrere useSelector-Aufrufe machen. Bei Objekten musst Du
              eventuell die
              <a href="https://react-redux.js.org/api/hooks#equality-comparisons-and-updates"
                >shallowEqual-Funktion</a
              >
              √ºbergeben.
            </li>
            <li class="fragment">
              Du kannst nat√ºrlich auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur den
              von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store kommt
              oder basierend auf dem Store "berechnet" wurde
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function AppHeader() {
              // "abgeleiteter" Zustand
              const hasDraftPost = useSelector(
                state => state.editor.draftTitle !== "" || state.editor.draftBody !== ""
              );
            }

            // √ºbergebene Selector-Callback-Funktion 
            //    wird bei JEDER √Ñnderung des Stores ausgef√ºhrt
            // AppHeader wird nur neu gerendert, 
            //    wenn sich deren R√úCKGABEWERT √§ndert
          </code></pre>
        </section>

        <section>
          <h3>Der Store</h3>
          <p>Ein <em>einziger</em> Store h√§lt den <em>kompletten</em> Zustand</p>
          <p class="fragment">
            Der Store wird allen Componenten √ºber die Wrapper-Komponente <em>Provider</em>
            zur Verf√ºgung gestellt
          </p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
  rootReducer // reducer
);
ReactDOM.render(
&lt;Provider store={store}>
    &lt;App />
&lt;/Provider>,
mountNode
);
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Dev Tools</h3>

          <p>
            Die Redux Dev Tools (Browser-Erweiterung) k√∂nnen in der Anwendung beim Konfiguration des
            Stores ein- oder ausgeschaltet werden
          </p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=de"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/reduxdevtools/" target="_blank"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section>
          <h2>√úbung: Der PostEditor mit Redux</h2>
          <p>Vorbereitung:</p>
          <ol>
            <li class="fragment">Workspace <code>blog-example/workspace-redux</code></li>
            <li class="fragment">Bitte <code>npm install</code> hier ausf√ºhren</li>
            <li class="fragment">
              danach <code>npm start</code> ausf√ºhren (den laufenden Prozess bitte beenden)
            </li>
            <li class="fragment">Den Workspace in der IDE/Editor √∂ffnen</li>
            <li class="fragment">
              Wenn die Anwendung l√§uft, bitte "Hand heben" in Teams, dann geht's weiter mit der
              eigentlichen √úbung üôã‚Äç‚ôÄÔ∏è
            </li>
          </ol>
        </section>
        <section>
          <h2>√úbung: Der PostEditor mit Redux</h2>
          <p>
            Der Workspace enth√§lt zwei Verzeichnisse: <code>ui</code> f√ºr Komponenten und
            <code>redux</code> f√ºr Logik. Diese Aufteilung ist <em>nicht empfehlenswert</em> in
            "echten" Anwendungen (dort bitte nach Fachlichkeit aufteilen), macht uns hier aber das
            Leben einfacher.
          </p>

          <p>Schritte:</p>
          <ol>
            <li class="fragment">
              Implementiere in <code>editor-slice.js</code> die Action Creator-Funktionen (siehe
              dort)
            </li>
            <li class="fragment">Vervollst√§ndige die reducer-Funktion</li>
            <li class="fragment">
              Migriere den (nicht funktionierenden) <code>PostEditor</code> so, dass der Draft Post
              aus dem Redux State gelesen und aktualisiert wird (<code>useSelector</code> und
              <code>useDispatch</code>)
            </li>
            <li class="fragment">
              Vervollst√§ndige die <code>AppHeader</code>-Komponente, so dass diese den "Clear
              Draft"-Button anzeigen und ausl√∂sen kann
            </li>

            <li class="fragment">In den drei Dateien sind todos eingetragen.</li>
            <li class="fragment">M√∂gliche L√∂sung in <code>steps/5-redux</code></li>
            <li class="fragment">Wenn Du fertig bist, bitte "Hand heben" in Teams üôã‚Äç‚ôÄÔ∏è</li>
          </ol>
        </section>
        <section>
          <h3>Redux</h3>
          <h2>Asynchrone Actions</h2>
          <p><em>Problem: Asynchronit√§t, z.B. beim Laden von Daten</em></p>
          <ul>
            <li class="fragment">
              Wo unterbringen?
              <ul>
                <li>Reducer sind Seiteneffekt-frei!</li>
                <li>Actions sind nur JavaScript-Objekte (keine Logik)!</li>
              </ul>
            </li>
            <li class="fragment">
              Weiteres Problem: fachliche Abl√§ufe meistens komplex(er) als nur eine Action.
              <ul>
                <li>
                  Typisch: Request Start, Request l√§uft, Request erfolgreich/Request fehlgeschlagen
                </li>
              </ul>
            </li>
            <li class="fragment">Redux bringt daf√ºr nix mit :-(</li>
            <li class="fragment">Es gibt aber Antworten: Thunk (Promi?), Saga, Observable</li>
          </ul>
        </section>
        <section>
          <h3>Redux</h3>
          <h2>Asynchrone Actions</h2>
          <em>Grunds√§tzliche Idee, bei allen Bibliotheken (Thunk, Saga, Observable) √§hnlich</em>
          <ul>
            <li class="fragment">
              Im <b>Action Creator</b> kann asynchroner Code ausgef√ºhrt werden
            </li>
            <li class="fragment">
              Es k√∂nnen <b>mehrere Actions</b> innerhalb des Action Creators dispatched werden
            </li>
            <li class="fragment">
              Alle genannten Bibliotheken werden √ºber <b>Middlewares</b> eingebunden
            </li>
          </ul>
        </section>

        <section>
          <h3>Middleware</h3>
          <ul>
            <li class="fragment">
              Eine Middleware-Funktion bekommt alle dispatchen Actions √ºbergeben, bevor sie in den
              Store gelangen
            </li>
            <li class="fragment">
              Die Middleware kann die Action annehmen, ver√§ndern, ablehnen und/oder weiterleiten
            </li>
            <li class="fragment">Typische Anwendungsf√§lle: Logging, asynchrone Verarbeitung</li>
            <li class="fragment">
              Die Middleware-Funktionen werden bei der Konfiguration des Stores angegeben
            </li>
            <li class="fragment">
              In der Regel schreibst Du keine Middlewares selbst, sondern verwendest fertige
            </li>
          </ul>
        </section>

        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>
            Schritt 1: <b>Dispatchen von Actions</b>: Komponente bleibt unver√§ndert, dispatched
            weiterhin eine Action, die wie eine "normale" Redux Action aussieht
          </p>
          <div class="fragment">
            <pre><code>
              import { loadPosts } from "./posts-slice";

              function App() {
                React.useEffect( 
                  () => dispatch(loadPosts()),
                  []
                );

                return ...;
            }
          </code></pre>
          </div>
        </section>
        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>
            Schritt 2: <b>Action Creator</b>: Hier k√∂nnen jetzt weitere Actions, auch asynchron,
            dispatched werden
          </p>
          <pre class="fragment"><code>
              // asynchroner Action Creator (pseudo code)
              function loadPosts() {

                dispatchAction "REQUEST_START"

                try {
                  posts = await loadPostsWithFetch() // ASYNCHRON !!!
                  dispatchAction "REQUEST_SUCCESS"
                  dispatchAction "SET_POSTS" posts
                } catch (err) {
                  dispatchAction "REQUEST_FAILURE" err
                }
              }
            </code></pre>
        </section>

        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>Schritt 3: <b>Reducer</b>: Unver√§ndert. Reducer empfangen "normale" Actions</p>
        </section>

        <section>
          <h2>Beispiele f√ºr Middlewares zum Arbeiten mit Asynchronit√§t</h2>
          <ul>
            <li>
              <a href="https://github.com/reduxjs/redux-thunk">Redux Thunk</a> (die "offizielle"
              L√∂sung)
            </li>

            <li>Redux Saga</li>
            <li>Redux Observable</li>
          </ul>
        </section>

        <section>
          <h2>Redux Thunk</h2>
          <ul>
            <li class="fragment">
              Ein Thunk Action Creator gibt kein Action-Objekt, sondern eine
              <b>Callback-Funktion</b> zur√ºck. Diese Funktion wird von Redux an die Middlewares
              weitergegeben. (Redux gibt nahezu alles, was wir dispatch √ºbergeben an die Middlewares
              bzw. den Store weiter...)
            </li>
            <li class="fragment">
              In der Callback-Funktion ist dann die (asynchrone) Logik untergebracht
            </li>
            <li class="fragment">
              Wenn die Thunk-Middleware eine Funktion entdeckt (und kein Objekt), ruft die
              Middleware diese Funktion auf, und √ºbergibt eine <code>dispatch</code>- und eine
              <code>getState</code>-Funktion
            </li>
            <li class="fragment">
              Mit <code>dispatch</code> kann die Callback-Funktion diverse weitere "regul√§re" und
              Thunk-Actions ausl√∂sen
            </li>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            export function loadPosts() {
              return (dispatch, getState) => {

                dispatch(postsLoading());

                fetch("http://localhost:7000/posts")
                  .then(response => response.json())
                  .then(json => {
                    dispatch(postLoadingSucceeded(json));
                  })
                  .catch(err => {
                    dispatch(postLoadingFailed(err));
                  });
              };
            }    </code></pre>
          </ul>
          <!-- <p class="fragment">
                <strong
                  >Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone
                  Operationen ausf√ºhren d√ºrfen</strong
                >
              </p> -->
        </section>
        <section>
          <h2>Redux Thunk</h2>
          <p>Thunk Actions k√∂nnen nicht nur f√ºr asynchone Anwendungsf√§lle verwendet werden</p>
          <ul>
            <li class="fragment">
              F√ºr Anwendungsf√§lle in den allgemein mehr als eine Action dispatched werden soll
            </li>
            <li class="fragment">
              Es ist darin erlaubt, beliebige Seiteneffkte auszuf√ºhren, z.B. eine uuid generieren
              oder auf die Uhrzeit zuzugreifen
            </li>
            <li class="fragment">
              Im Gegensatz zum Reducer hat ein Action-Creator Zugriff auf den gesamten State und
              kann z.B. eine Cache-Funktionali√§t implementieren
            </li>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            export function loadPostsWithCache() {
              return (dispatch, getState) => {

                if (getState().posts.posts) {
                  // Posts sind schon geladen => nicht erneut laden
                  return;
                }


                dispatch(postsLoading());

                // ...wie gesehen: Posts laden etc.
              };
            }    </code></pre>
          </ul>
          <!-- <p class="fragment">
                <strong
                  >Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone
                  Operationen ausf√ºhren d√ºrfen</strong
                >
              </p> -->
        </section>

        <section>
          <h3>Redux Toolkit</h3>
          <p>
            <em
              >"The official, opinionated, batteries-included toolset for efficient Redux
              development"</em
            >
          </p>
          <ul>
            <li><a href="https://redux-toolkit.js">https://redux-toolkit.js.org/</a></li>
            <li>
              Vorkonfiguriertes Setup (inklusive
              <a href="https://github.com/immerjs/immer">immer</a> f√ºr Reducer und Thunk Middleware)
            </li>
            <li>
              Vereinfacht erheblich das Arbeiten mit Reducer, generiert z.B. Action Creator zur
              Laufzeit
            </li>
            <li>Vereinfacht typische Anwendungsf√§lle wie API Calls</li>
            <li>
              Outstanding TypeScript support! Ihr wollt das nicht ohne TypeScript verwenden üòâ
            </li>
          </ul>
        </section>

        <section>
          <h3>createSlice</h3>
          <ul>
            <li class="fragment">
              Ein "Slice" repr√§sentiert einen fachnlichen "Schnitt" in Eurer Anwendung
            </li>
            <li class="fragment">
              Ein Slice wird mit der Funktion <code>createSlice</code> erzeugt
            </li>
            <li class="fragment">Diese Funktion erwartet ein Konfigurationsobjekt</li>
            <li class="fragment">
              √úber dieses Objekt k√∂nnen reducer und der initiale Zustand festgelegt werden
            </li>
            <li class="fragment">
              F√ºr jede reducer-Funktion wird per Default ein action-creator automatisch generiert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              name: "hello",
              initalState: { name: "world" },
              reducers: {
                greet(state, action) {
                  // ...
                }
              }
            })
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const dispatch = useDispatch();

            dispatch(hello.actions.greet({
              name: "World"
            }))
          </code></pre>
        </section>

        <section>
          <h3>reducer</h3>
          <ul>
            <li class="fragment">
              Wie gesehen, bekommen reducer den slice-State und die Action √ºbergeben
            </li>
            <li class="fragment">
              Die reducer-Funktionen werden mit <b>immer</b> umschlossen, so dass der State dort
              <b>mutable</b> ist (bzw so aussieht, als ob er mutable ist)
            </li>
            <li class="fragment">
              Der State kann deshalb direkt bearbeitet werden oder es kann ein komplett neues Objekt
              zur√ºckgegeben werden
            </li>
          </ul>
          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              // ...
              reducers: {
                greet(state, action) {
                  state.name = action.payload.name;
                },
                clear() {
                  return { name: "" };
                }
              }
            })
          </code></pre>
        </section>
        <section>
          <h3>reducer und Action Creator</h3>
          <ul>
            <li class="fragment">
              Zu jeder reducer-Funktion wird eine Action-Creator-Funktion erzeugt
            </li>
            <li class="fragment">
              Diese Funktion erwartet einen Parameter: den Action-Payload (oder gar nichts)
            </li>
            <li class="fragment">
              Die Funktionen liegen unterhalb von <code>sliceName.actions</code> und k√∂nnen von dort
              exportiert werden, so dass die Anwendung darauf Zugriff hat
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              // ...
              reducers: {
                
                greet(state, action) { ... },
                clear() { ... }
                }
              }
            })   
          
            export const { greet, clear } = hello.actions;
          
          </code></pre>

          <pre class="fragment"><code class="javascript">
            import { greet } from "./hello-slice";

            // in der Komponente
            dispatch(greet({name: "Klaus"}));

            // ohne payload
            dispatch(clear());
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Asynchrone Actions</h3>
          <ul>
            <li class="fragment">Die Redux Thunk Middleware ist in Redux Toolkit integriert</li>
            <li class="fragment">
              Asynchrone Action Creator k√∂nnen aber nicht als reducer definiert werden, du schreibst
              sie wie in Redux au√üerhalb von createSlice hin.
            </li>
            <li class="fragment">
              Mit <a href="https://redux-toolkit.js.org/api/createAsyncThunk">createAsyncThunk</a>
              kannst Du vereinfachte Thunk-Actions schreiben, die automatisch Lifecycle Actions
              dispatchen (request started, request failed, ...)
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Toolkit Beispiel</h3>

          <p>üëâüëâ Beispiel: 20_redux_toolkit_workspace</p>
          <p>üëâüëâ editor-slice konvertieren, PostEditor anpassen</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Happy Statemanagement üçª</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
        <section>
          <img src="slides/images/Deckblatt-und-Schlussblatt_devmedia_Trainings.png" />
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
    <script>
      const isLocal =
        window.location.hostname.indexOf("localhost") !== -1 ||
        window.location.hostname.indexOf("127.0.0.1") !== -1 ||
        window.location.href.startsWith("file:///");
      Reveal.addEventListener("ready", function (event) {
        $("li").addClass("fragment");

        // make all links open in new tab
        $("a").attr("target", "_blank");

        if (isLocal) {
          // only applies to presentation version
          Reveal.configure({ controls: false });
        } else {
          // only applies to public version
          $(".fragment").removeClass("fragment");
        }
      });
    </script>
  </body>
</html>
