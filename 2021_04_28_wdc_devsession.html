<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>Modernes Statemanagement f√ºr React</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h4 style="margin-top: 7rem">
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a>
            </span>
          </h4>
          <h2 class="title" style="font-size: 7rem">
            <b>"Modernes" Statemanagement</b>
          </h2>
          <h2 class="title" style="font-size: 7rem">
            <b>f√ºr React</b>
          </h2>
          <h3 style="margin-top: 7rem">
            <a
              href="https://www.web-developer-conference.de/programm/#/talk/modernes-statemanagement-fur-react"
              >Web Developer Conference, 28. April 2021 | DevSession</a
            >
          </h3>

          <h4 style="margin-top: 7rem">
            <span class="transparent-bg">
              E-Mail:
              <a href="mailto://nils@nilshartmann.net" target="_blank">nils@nilshartmann.net</a> |
              Twitter:
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>
        </section>

        <!--


Zustandsmanagement kann schnell zu einer echten Herausforderung werden, gerade in gr√∂√üeren React-Anwendungen. 

Denn Daten sollen ja zuverl√§ssig und schnell in den Komponenten zur Verf√ºgung stehen, die sie ben√∂tigen, 
ohne dass es etwa zu Inkonsistenzen kommt. Und auch der Code sollte verst√§ndlich und testbar bleiben. 
In dieser DevSession sehen wir uns einige M√∂glichkeiten "zeitgem√§√üen" Zustandsmanagements an. Als Grundlage nutzen wir die React-eigenen Mittel zum Statemanagement, 
die sich mit der Hooks und Context API umsetzen lassen. 

Au√üerdem stelle ich externe Bibliotheken f√ºrs Statemanagement vor wie Redux/Redux Toolkit und MobX. Wir sehen uns deren wichtigste Konzepte an und ordnen ein, 
f√ºr welche Anwendungen und Use-Cases sie jeweils am besten geeignet sind. 

Das ganze nat√ºrlich anhand vieler Code-Beispiele, um einen Eindruck der praktischen Umsetzung dieser Ans√§tze zu erhalten.

        -->

        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em></p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zeitplan 

            * 09:00-10:15
            * ca. 10:15-10:30 Pause ‚òïÔ∏è 
            * 10:30-11:45
            * ca. 11:45-12:00 Pause üò¥
            * 12:00-13:00 

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Beteiligt Euch gerne 

            * Ihr k√∂nnt jederzeit Fragen stellen, kommentieren, Feedback geben etc.
            * Ich versuche, zwischendurch immer wieder, Code im Editor zu zeigen
              * Dadurch sind wir flexibel und nicht an eine feste Slide-Reihenfolge gebunden
              * Au√üerdem f√ºr Euch (hoffentlich) spannender als Slide-Watching
            * Beteiligung per Chat oder Audio
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Zum Einstieg...

            * Was sind Eure Vorkenntnisse?
            * Was verbindet ihr mit Statemanagement? Was m√∂chtet ihr heute lernen?
            * Bitte √∂ffnet [Mentimeter](https://www.menti.com) und gebt dort den Code ein (Chat!)
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Agenda</h3>

          <ul>
            <li class="fragment"><a href="#/t-intro">Einf√ºhrung: Arten von State</a></li>

            <li class="fragment">
              React Bordmittel: <a href="#/t-usereducer">useReducer</a> und
              <a href="#/t-usecontext">Context</a>
            </li>

            <li class="fragment"><a href="#/t-query-libs">Bibliotheken zum Data Fetching</a></li>
            <li class="fragment">
              Entstaubter Klassiker: <a href="#/t-redux">Redux</a> und
              <a href="#/t-redux-toolkit">Redux Toolkit</a>
            </li>
            <li class="fragment">In frischem Gewand: <a href="#/t-mobx">MobX</a></li>
            <li class="fragment"><a href="#/t-recoil">Ausblick: Recoil</a></li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <div style="margin-top: 4rem">
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                ><a href="https://react.schule/wdc21-state"
                  >https://react.schule/wdc21-state</a
                ></span
              >
            </p>
          </div>
          <div style="margin-top: 4rem">
            <h3><span class="transparent-bg">Beispiele</span></h3>
            <p>
              <span class="transparent-bg"
                ><a href="https://github.com/nilshartmann/react-state-workshop"
                  >https://github.com/nilshartmann/react-state-workshop</a
                ></span
              >
            </p>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
    ## "The Art of State"
    
    ### Meine Artikelserie bei heise developer zum Thema

    * [Teil 1: Zustandsmanagement in React-Anwendungen](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendungen-4934595.html)
    * [Teil 2: React Context API und Redux ](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendung-Teil-2-4990188.html)
    * [Teil 3: Weitere Bibliotheken](https://www.heise.de/ratgeber/The-Art-of-State-Zustandsmanagement-in-React-Anwendung-Teil-3-5054351.html)

  </textarea
          >
        </section>

        <section data-markdown id="t-intro">
          <textarea data-template>
            ## State... ein paar Basics

            * Wor√ºber man sich Gedanken machen kann/sollte
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Verschiedene Arten von State 1

            ### "Reichweite"
            * Lokaler State: Zustand, der nur von einer (logischen) Komponente ben√∂tigt wird
            * Globaler State: wird von der ganzen Anwendung oder gro√üen Teilen verwendet
            * Es gibt nat√ºrlich Abstufungen (Regionaler State? ü§î)

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Was ist global, was ist lokal?

            * üëâ Ich zeige euch eine Anwendung, und wir sch√§tzen ein, was globaler und was lokaler Zustand sein k√∂nnte
            * üëâ es gibt kein "richtig" oder "falsch"
            * Beispiel 1: PostEditor
            * Beispiel 2: angemeldeter Benutzer
            * Beispiel 3: Sortierreihenfolge
            * Beispiel 4: Einzelner Blogpost

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Wo wird Zustand gehalten?

            * Lokal oder global in der Komponentenhierarchie (React, Recoil (?))
            * Global au√üerhalb der Komponentenhierarchie (Redux, MobX)
            * In der URL üò≥
              * Was in die URL kommt ist eine **fachliche**, keine **technische** Frage
              * Welche Informationen m√∂chte ich verlinkbar haben? Aktuellen Blog-Post? Sortierreihenfolge?
            * Auf dem Server 
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Zustand und berechneter Zustand

            * Eine Information unserer Anwendung sollte immer nur einem Zustand, einer Stelle liegen
            * Daraus k√∂nnen dann Werte abgeleitet oder berechnet werden, z.B.
              * sortierte oder gefilterte Listen
              * berechnete Werte (z.B. ein Brutto-Preis)
              * formatierte Daten (z.B. ein voller Name samt Anrede und Titel)
            * In der Regel werden solche Daten nicht in einen Zustand gelegt, sondern beim Rendern berechnet
            * Mit `useMemo` k√∂nnen Werte in React gecached werden
            
      
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Verschiedene Arten von State 3

            ### Struktur von lokalem Zustand
            * "Einfacher" Zustand: mehrere useState-Aufrufe in einer Komponente
            * "Komplexer" Zustand: *ein* State, der ein Objekt enth√§lt
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Hinweis: TypeScript

            * Ich zeige heute Beispiele in JavaScript und TypeScript
            * Aber **alle** Bibliotheken, die ich zeige funktioneren hervorragend mit TypeScript!
            * F√ºr "gr√∂√üere" Anwendungen w√ºrde ich immer TypeScript empfehlen
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Arbeiten mit immutable Objekten</h3>

          <ul>
            <li class="fragment">Zustand in React ist grunds√§tzlich immutable</li>

            <li class="fragment">
              Objekte (oder Arrays) im Zustand m√ºsst ihr also kopieren und dann die Kopie bearbeiten
            </li>

            <li class="fragment">Das gilt sowohl f√ºr useState, useReducer, Redux, ...</li>
          </ul>

          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            function BlogPost() {
              const [person, setPerson] = React.useState({});

              function handlePersonChange(newCity) {
                // verboten!
                person.address.city = newCity;

                // ü§®
                setPerson(person);
              }

            }
          </code></pre>
        </section>

        <section>
          <h3>Beispiel: Arbeiten mit immutable Objekten (ES6)</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
        // Objekt-Spread-Operator zum Kopieren und ver√§ndern

        const newObject = {
          ...oldObject, // altes Objekt hier "einf√ºgen"
          updatedProperty: "new value" // (ausgew√§hlte) Werte in NEUEM Objekt ver√§ndern
        }
                    </code></pre>
          <h3 class="fragment">Object-Spread-Operator kopiert nur "flach"</h3>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// Beispiel mit Verschachtelung:
const oldPerson = { name: "Klaus", address: { city: "Berlin", country: "Germany"} };                      

const newPerson = {
  ...oldPerson, // altes Objekt hier "einf√ºgen"

  // address muss nun auch kopiert werden:
  address: { ...newPerson.address, city: "Hamburg" } 
}
            </code></pre>
          <h3 class="fragment">√Ñndern von Arrays mit Array-Spread-Operator</h3>
          <pre class="fragment"><code class="javascript">
            // Ver√§ndern von Arrays:

            const newArray = oldArray.map(oldEntry => {
              if (oldEntry.id === "user-1") { // dieses Element soll ver√§ndert werden
                return { ...oldEntry, name: "Klaus" }
              }
              return oldEntry; // unver√§ndert
            });
    
            // newArray ist eine Kopie, mit ggf. ver√§nderten Eintr√§gen

      </code></pre>
        </section>

        <section>
          <h3>Fazit: Arbeiten mit immutable Objekten (ES6)</h3>

          <h3>üò± üò∞ üò®</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Immer f√ºr Arbeiten mit unver√§nderlichen Datenstrukturen

          <img src="slides/images/immer.png" /> 

          * [ImmerJs](https://immerjs.github.io/immer/docs/introduction): _Create the next immutable state tree by simply modifying the current tree_
          * Konzept: altes Objekt wird in eine Funktion gesteckt, die daraus ein _Draft_ erzeugt
          * Das _Draft_ wird mit regul√§ren JavaScript APIs ver√§ndert, als wenn es mutable w√§re
          * Immer zeichnet die √Ñnderungen auf
          * Zum Schluss werden die √Ñnderungen auf eine Kopie des alten Objektes angewendet

        </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Immer: produce-Funktion</h3>
          <pre class="fragment"><code class="javascript">
            import produce from "immer";

            const person = { name: "Klaus", address: { city: "Berlin", country: "Germany" }, hobbies: ["Musik"] };

            const newPerson = produce(person, draft => {
              draft.name = "Susi";
              draft.address.city = "Hamburg";
              draft.hobbies.push("Programmieren")
            })

            newPerson; // Neues Objekt!
            newPerson.name; // Susi
            newPerson.address // Neues Objekt!
            newPerson.address.city; // Hamburg
            newPerson.hobbies // Neues Array! (Musik, Programmieren)
          </code></pre>
          <div class="fragment">
            <p>
              Die <b>produce</b>-Funktion bekommt ein Objekt √ºbergeben, sowie eine zweite Funktion,
              die von immer mit einem Draft aufgerufen wird.
            </p>
            <p>Dieses Draft kann ver√§ndert werden</p>
            <p>
              Der R√ºckgabe-Typ der produce-Funktion ist dann eine Kopie des alten Objektes mit den
              √Ñnderungen, die auf dem Draft vorgenommen wurden.
            </p>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer mit useState</h3>

          <pre class="fragment"><code class="javascript">
            function PersonEditor() {
              const [person, setPerson] = React.useState({});
  
              function handlePersonChange(newCity) {
                const newPerson = produce(person, draft => {
                  // draft kann ver√§ndert werden, als ob es ein mutable Objekt sei
                  // und zwar auf allen Ebenen des Objekt-Graphen
                  draft.address.city = newCity;
                })
  
                // üòä
                setPerson(newPerson);
              }
            }
              
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel: Immer mit useImmer</h3>

          <ul>
            <li class="fragment">
              <a href="https://github.com/immerjs/use-immer">useImmer</a> kann als Ersatz f√ºr
              useState verwendet werden
            </li>

            <li class="fragment">
              Statt einer set-Funktion wird eine update-Funktion zur√ºckgeliefert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function PersonEditor() {
              // useImmer statt useState
              const [person, updatePerson] = useImmer({});
  
              function handlePersonChange(newCity) {
                // updatePerson liefert ein draft f√ºr den aktuellen Zustand
                // und setzt den draft dann als neuen Zustand
                updatePerson(draft => draft.address.city = newCity)
              }
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Immer: wann verwenden

            * immer lohnt sich nur bei komplexen Objekten
            * Einfache Objekte kann man auch gut mit ES6 Operatoren verarbeiten
            * Bei der Arbeit mit Reducern (Redux, useReducer) sehr zu empfehlen
          </textarea>
        </section>

        <!-- <section>
          <h3>N√§chster Schritt</h3>
          <h2>Zustand "verteilen"</h2>
        </section>

        <section data-markdown>
          <textarea data-template>
    ### Erinnerung:

    * **Zustand** wird von Parent-Komponenten nach unten gereicht (√ºber **Properties**)
    * Die Unterkomponenten k√∂nnen den Zustand darstellen (oder andere Dinge davon ableiten), aber ihn nicht **ver√§ndern**
    * (Unterkomponenten k√∂nnen zus√§tzlich eigenen Zustand haben)
    * Oberkomponenten k√∂nnen au√üerdem Callback-Funktionen an ihre Unterkomponenten √ºbergeben
    * √úber die Callback-Funktionen k√∂nnen Unterkomponenten den Oberkomponenten Ereignisse schicken
    * Die Oberkomponente kann auf das Ereignis z.B. mit einer State-√Ñnderung reagieren, so dass Ober- und Unterkomponente neu gerendert werden
    * Das Durchreichen von State- und Callbacks ist √ºber mehr als eine Ebene erlaubt (und gew√∂hnlich)

    <img class="fragment" style="height:600px" src="slides/images/state/datenfluss.svg" />
  </textarea
          >
        </section>

        <section>
          <h3>Beispiel</h3>
          <pre class="fragment"><code class="javascript">
    function App() {
      const [user, setUser] = React.useState(...);

      function handleFullNameChange(newFullName: string) { setUser(...) }

      return &lt;...>
        &lt;TextInput label="Full Name" value={user.fullName} 
           onTextChange={handleFullNameChange} />
      &lt;...>
    }
        </code></pre>

          <pre class="fragment"><code class="javascript">
          // kein eigener State!
          function TextInput(props) {
            return &lt;...>
              &lt;input value={props.value}
                 onChange={e => props.onTextChange(e.target.value)} />
            &lt;...>
          }
              </code></pre>
        </section> -->

        <section data-markdown id="t-usereducer">
          <textarea data-template>
        ### Verwaltung von komplexem Zustand

        ## Reducer-Funktionen und useReducer-Hook
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### Verwaltung und √Ñnderung von Zustand

        * Wir halten den Zustand lokal in einer Komponente
        * S√§mtliche √Ñnderungen daran passieren innerhalb der Komponente
        * Mit einer **reducer-Funktion** kann die Verwaltung des Zustandes aus der Komponente herausgel√∂st werden
          * (Der Zustand geh√∂rt aber weiterhin der Komponente, wenn Komponente weg, Zustand weg...)
        * Gr√ºnde k√∂nnten sein:
          * besser testbar (Reducer sind pure Funktionen, normaler Unit-Test gen√ºgt)
          * Wiederverwendbar (keine Abh√§ngigkeit auf React)
          * Trennung UI/Logik, k√∂nnte zu √ºbersichtlicherem Code f√ºhren, Komponenten-Code wird "entlastet"
        * Verwendet jemand useReducer? Wof√ºr? üôã  
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useReducer-Hook f√ºr komplexen Zustand</h3>

          <p>Beispiel: 05_reducer/01_reducer_complete</p>
        </section>

        <section>
          <h3>useReducer-Hook</h3>
          <p>Eine reducer-Funktion...</p>
          <ul>
            <li class="fragment">
              ...erh√§lt einen (vorherigen) Zustand und eine Action als Parameter √ºbergeben
            </li>
            <li class="fragment">
              <b>Actions</b> sind anwendungsspezifische, beliebige JavaScript-Objekte
            </li>
            <li class="fragment">...verarbeitet die Action</li>
            <li class="fragment">...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li class="fragment">...muss Seiteneffekt frei sein ("pure function")</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
          reducer(old_state, action) => new_state
        </code></pre>

          <p class="fragment">
            <em
              >Reducer sind zentrales Konzept von Redux, kommen aber auch in anderen Bereichen vor
              (z.B. <code>Array.reduce</code>)</em
            >
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Actions</h3>
          <ul>
            <li class="fragment">Pure JavaScript-Objekte</li>
            <li class="fragment">Haben √ºblicherweise <b>type</b> und <b>payload</b></li>
            <li class="fragment">√úber das <b>type</b>-Property k√∂nnen sie identifiziert werden</li>
            <li class="fragment">Der <b>Payload</b> enth√§lt Action-spezifische Daten</li>
          </ul>

          <pre class="fragment"><code class="javascript">
        const addItemAction = {
          type: "addItem",
          itemName: "Book"  // Action-spezifischer Payload (hier: Name des neuen Eintrags)
          itemQuantity: 
        }
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion</h3>
          <ul>
            <li class="fragment">
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li class="fragment">
              Zustand ist immutable! Kann mit <code>immer</code> kombiniert werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function apiReducer(state, action) {
  return produce(state, newState => { // immer!
    switch (action.type) {
      case "addItem": 
        let currentItem = newState.find(item => item.name === action.itemName);
        if (currentItem) {
          currentItem.quantity += parseInt(action.itemQuantity);
        } else {
          // ...
          newState.push(currentItem);
        }
        case "...":
        // ...
      }
    })
  }
      </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useReducer-Hook</h3>
          <ul>
            <li class="fragment">
              Mit dem <b>useReducer</b>-Hook wird die reducer-Funktion in der Komponente registriert
            </li>
            <li class="fragment">
              Der Hook bekommt die reducer-Funktion √ºbergeben und den initialen Zustand (√§hnlich wie
              useState)
            </li>
            <li class="fragment">
              Der Hook liefert ein Array zur√ºck mit zwei Eintr√§gen: dem aktuellen Zustand und der
              <b>dispatch</b>-Funktion. Auch hier √§hnlich wie bei useState: Zustand und Funktion zum
              √Ñndern des Zustandes
            </li>
            <li class="fragment">
              Mit der dispatch-Funktion k√∂nnen Actions an den Reducer gesendet werden
            </li>
            <li class="fragment">
              Der reducer aktualisiert verarbeitet die Action, liefert neuen Zustand zur√ºck,
              Komponente wird neu gerendert (wie bei useState)
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
        function App() {
          const [items, dispatch] = React.useReducer(apiReducer, [{name: "book", quantity: 1}]);

          function handleUpdateClick() {
            dispatch({ type: "addItem", { itemName: "...", itemQuantity: 3 }});
          }

          // ...

        }
      </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### useReducer: wann?

            * Verarbeitung von komplexem Zustand mit komplexen Regeln
            * Man m√∂chte die Logik nicht React-abh√§ngig haben
          </textarea>
        </section>
        <section data-markdown id="t-usecontext">
          <textarea data-template>
        ### N√§chster Schritt: Globaler Zustand

        * Man kann Zustand in **lokalen Zustand** und **globalen Zustand** einteilen
        * **Lokaler Zustand** ist Zustand, der "mehr oder weniger" einer Komponente zur Verf√ºgung steht
        * **Globaler Zustand** hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon zust√§ndig
        * Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition

        * Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme
        * Es spricht nichts dagegen, globalen Zustand, mit useState/useReducer zu verwalten, aber...
        * Du musst ihn unter Umst√§nden weit nach unten reichen
        * oder andersrum: er muss sehr weit oben aufgeh√§ngt sein, um z.B. f√ºr verschiedene Ansichten zur Verf√ºgung zu stehen, oder Ansichtswechsel zu "√ºberleben"
      </textarea
          >
        </section>

        <section data-markdown>
          <textarea data-template>
        ### React Context

        * Der **React Context** ist eine M√∂glichkeit, globalen Zustand Komponenten zur Verf√ºgung zu stellen, ohne ihn √ºber Properties durchreichen zu m√ºssen
        * Es gibt dabei eine **Provider** Komponente, die ein beliebiges Objekt, den Kontext, allen unterhalb liegenden Komponenten zur Verf√ºgung stellt
        * Das Objekt kann Daten und (Callback-)Funktionen enthalten
          * Konzept fast wie "klassisches" React mit durchreichen von Properties und Callbacks - nur ohne durchreichen, das passiert transparent‚Äû
        * Du kannst beliebig viele Kontexte in deiner Anwendung verwenden. Dann hast Du entsprechend mehr Provider-Komponenten.
      </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Beispiel</h3>
          <p>üëâ examples/context/ CounterContext und App implementieren!</p>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Context: Wann verwenden?

            * Mehr oder weniger "statische" globale Daten (z.B. Theme, Benutzer)
              * F√ºr Daten, die sich h√§ufig √§ndern, wird vom Context (noch) abgeraten, k√∂nnte sich aber √§ndern
            * Zustand f√ºr "logische" Komponenten (Beispiel: Formular, dessen Kinder auf Formular-Daten Zugriff brauchen)
            * Zur Verf√ºgung stellen von Infrastruktur-Diensten (als "Dependency Injection"-Ersatz)
              * Bereitstellen z.B. von APIs in der Anwendung, die ihrerseits reaktiv sein sollen/m√ºssen
              * Z.B. Http-Funktion, die REST Requests macht, und den aktuellen Benutzer (aus anderem Context?) verwendet
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Factory</h3>
          <ul>
            <li class="fragment">Der Provider stellt ein beliebiges Objekt zur Verf√ºgung</li>
            <li class="fragment">
              Daf√ºr muss ein Context-Objekt mit <code>React.createContext</code> erzeugt werden.
              Dieses Objekt enth√§lt die Provider- und die Consumer-Komponente
            </li>
            <li class="fragment">(Consumer-Komponente ist mit Hooks API irrelevant)</li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        import react from "React";

        const ThemeContext = React.createContext();

        // erzeugt:
        // ThemeContext.Provider 
        // ThemeContext.Consumer (irrelevant mit Hooks API)
                </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Context: Provider</h3>
          <ul>
            <li class="fragment">
              Die mit <code>createContext</code> erzeugte Provider Komponente erh√§lt ein Objekt als
              Properties, das sie allen unterhalb liegenden Komponenten (<code>children</code>) zur
              Verf√ºgung stellt.
            </li>
            <li class="fragment">Die Verwendung ist wie eine "normale" Komponente</li>
            <li class="fragment">
              √úblicherweise baut man sich eine Komponente darum, die dann auch die Daten h√§lt, die
              √ºber den Context zur Verf√ºgung gestellt werden sollen
            </li>
            <li class="fragment">Auch hierbei handelt es sich um eine "normale" Komponente:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
        const ThemeContext = React.createContext();

        function ThemeContextProvider(props) {
          const [themeName, setThemeName] = React.useState();


          return &lt;ThemeContext.Provider value={{
            currentTheme: themeName,
            setCurrentTheme: setThemeName 
          }}>
          {props.children}
        &lt;/AuthContext.Provider>;
      }
</code></pre>
        </section>
        <!-- ============================================================================= -->
        <section>
          <h3>Context: Consumer</h3>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <ul>
            <li class="fragment">
              In allen Komponenten unterhalb der Provider Komponente, kann mit
              <code>useContext</code> auf das bereitgestellte Objekt zugegriffen werden
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
function TextInput() {
const { themeName } = React.useContext(ThemeContext);

return &lt;div className={`theme-${themeName}`}>&lt;input ... />&lt;/div>
}            
    </code></pre>
          <p class="fragment">
            Wenn der Kontext sich √§ndert, werden alle Konsumer automatisch neu gerendert
          </p>
          <pre class="fragment"><code class="javascript">
function ThemeChooser() {
  const { setThemeName } = React.useContext(themeContext);
  return &lt;div>
    &lt;button onClick={() => setThemeName("dark")}>Dark Theme&lt;/button>
    &lt;button onClick={() => setThemeName("light")}>Light Theme&lt;/button>
    &lt;/div>
}                
    </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Custom Hook f√ºr Context-Zugriff</h3>

          <ul>
            <li class="fragment">
              Du kannst einen Custom Hook f√ºr den Zugriff auf deinen Kontext bauen
            </li>
            <li class="fragment">
              Dann ist die Technologie (Context) gekapselt und Du hast eine "fachliche" API
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            export function useTheme() {
              return React.useContext(ThemeContext);
            }
          </code></pre>

          <pre class="fragment"><code class="javascript">
            // ThemeContext.tsx
            function TextInput(props) {
              const { themeName } = useTheme();
              
              // ...
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section id="t-query-libs">
          <h2>Query Libraries</h2>
          <h3>F√ºr Daten vom Server (Caching)</h3>

          <ul>
            <li class="fragment">Ein "Speziallfall" von globalen Daten</li>

            <li class="fragment">
              Daten, die vom Server gelesen werden und in der Anwednung z.B. gecached werden sollen
            </li>

            <li class="fragment">
              M√∂glicherweise werden diese Daten sogar nur zur Darstellung ben√∂tigt...
            </li>

            <li class="fragment">
              ...oder werden nur durch Server-Aufruf ge√§ndert, aber nicht direkt am Client
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Data Libraries f√ºr React: Anforderungen

            * Daten laden/schreiben, HTTP GET, POST, PUT, DELETE, ...
            * Caching samt korrektem Invalidieren...
            * Requests sollen nicht bei jedem Rendern ausgef√ºhrt werden
            * globales(!) Caching: Daten sollen √ºber Komponetengrenzen und -wechsel erhalten bleiben
            * Re-fetching?
            * Fehlerbehandlung
            * Request-Lebenszyklus: L√§uft mein Request noch? (Wie) wurde er beendet? 
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Data Libraries f√ºr React: Typische Vertreter

            * [SWR](https://swr.vercel.app/) und [React Query](https://react-query.tanstack.com/)
            * Neu f√ºr Redux (Beta!): [Redux Toolkit Query](https://rtk-query-docs.netlify.app/)
            * Erste(?) Lib dieser Art: [Apollo](https://www.apollographql.com/docs/react/) (f√ºr GraphQL)
            * Idee bei allen √§hnlich: es gibt einen Custom-Hook, der Daten l√§dt/schreibt, man bekommt Request Status/Daten zur√ºck, Ergebnisse werden gecached
            * Automatisches Refresh der Daten z.B. nach Zeitintervall oder re-mount einer Komponente
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Beispiel: SWR

            * `15_datalib/02_datalibs_finish`
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            Wann verwenden?

            * Anwendungen mit Daten, die an vielen Stellen Daten vom Server lesen/dahin schreiben
            * F√ºr lokale Caching von serverseitigen Daten
            * "Echte" API Requests (mit Loading Indicatoren, Refetching etc)
              * F√ºr einmalige Login-Maske wahrscheinlich zu viel des Guten
            * Insbesondere wenn keine anderen Statemanagement Libraries zum Einsatz kommen (sollen)
              * Er√ºbrigt in vielen F√§llen den Einsatz von Redux o.√§.
              * Grunds√§tzlich kombinierbar mit anderen State-Libs und nat√ºrlich dem Context
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>DataLibs: Examplarische Verwendung</h3>
          <p><em>APIs sehen bei SWR, React-Query und Apollo √§hnlich aus</em></p>

          <pre class="fragment"><code class="javascript">
            // konzeptionell
            function User() {
              // R√ºckgabe-Wert enth√§lt Informationen √ºber den Request-Status
              // Parameter f√ºr useXyz ist ein Cache-Key (kann z.B. die URL sein)
              // es gibt - je nach Lib - diverse Optionen zur Konfiguration!
              const { data, loading, error } = useSWR("/api/user");

              if (loading) {
                return &lt;h1>User is loading &lt;/h1>;
              }

              if (error) {
                return &lt;h1>User could not be loaded&lt;/h1>
              }

              if (data) {
                return &lt;div>...&lt/div>
              }
  
            }

          </code></pre>
        </section>

        <section id="t-redux">
          <h2>Redux</h2>
          <h3>External Statemanagement</h3>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Externes Statemanagement

            * **Externes** Statemanagement bedeutet, dass der Zustand aus deinen Komponenten herauswandert
            * Mit externem Statemanagement wird in der Regel **globaler Zustand** verwaltet
            * Es gibt mehrere Bibliotheken, die bekanntesten sind:
              * [Redux](https://redux.js.org/)
              * [MobX](https://mobx.js.org/README.html)
              * [Recoil](https://recoiljs.org/)
            * Beide sind zun√§chst React-unabh√§ngig und f√ºr mehrere Webframeworks verf√ºgbar
            * D.h. die Logik, die Du damit entwickelst kannst Du prinzipiell auch mit anderen Webframeworks nutzen
            * Weitere Vertreter: [Recoil](https://recoiljs.org/) ebenfalls von Facebook, [OvermindJS](https://overmindjs.org/), von Codesandbox
          </textarea>
        </section>

        <section id="redux">
          <h2>Beispiel: Redux</h2>
          <p>Anwendung: üëâ 20_redux/2-redux_complete</p>
        </section>
        <section>
          <h3>Beispiel: Redux</h3>

          <ul>
            <li class="fragment">Der "Klassiker" unter den State Libs</li>
            <li class="fragment">Mit Sicherheit h√∂chste Verbreitung, meistes Wissen etc.</li>
            <li class="fragment">Exzellentes Developer Tooling</li>
            <li class="fragment">
              (Vor-)Urteile

              <ul>
                <li class="fragment">viel Boilerplate-Code n√∂tig</li>
                <li class="fragment">
                  verwendetes Konzept von Higher-Order-Components schwer verst√§ndlich
                </li>
                <li class="fragment">kein Support f√ºr Data Fetching</li>
              </ul>
            </li>
            <li class="fragment">Hier hat sich aber einiges getan!</li>
            <li class="fragment">Hooks API, Redux Toolkit</li>
          </ul>
        </section>
        <section>
          <h3>Wiederholung</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px" />
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px" />
        </section>

        <section>
          <h2>Redux im Code</h2>
          <p>üëâ 2-redux-workspace (PostEditor und post-slice)</p>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Redux: Konzepte

            * **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
            * **Actions** und **Reducer** wie bei useReducer gesehen, hier aber global f√ºr die ganze Anwendung
              * **Actions**: Einfache JavaScript-Objekte, die beschreiben was in einer Anwendung passiert. Bestehen aus einem Type und einem fachlichen Payload.
              * **Reducer**-Funktionen: Funktionen, in denen die Logik zur Verarbeitung des Zustands untergebracht ist. Sie erhalten eine Action und einen (alten) Zustand, verarbeiten die Action und liefern neuen Zustand zur√ºck.
            * **Action Creator**: Factory-Funktion, die ein Action Objekte erzeugt
          </textarea>
        </section>

        <section>
          <h3>Redux: Store, Reducer und Actions</h3>
          <ul>
            <li class="fragment">
              Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen
              verwaltet
            </li>
            <li class="fragment">
              Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die
              reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des
              gloablen Zustands zugreifen. Ein Teil-Zustand wird auch als "Slice" bezeichnet (also
              ein Anwendungsteil)
            </li>
            <li class="fragment">
              Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so
              etwas wie eine Tabelle
            </li>
            <li class="fragment">
              Die reducer werden beim Starten der Anwendung in Redux registriert
            </li>
            <li class="fragment">
              Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine
              Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
              Anwendungsteile k√∂nnen darauf reagieren
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions ausl√∂sen</h3>
          <ul>
            <li class="fragment">Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li class="fragment">
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function PostEditor() {
              const dispatch = useDispatch();

              function handleTitleChange(newTitle) {
                dispatch({ type: "editor/setDraftTitle", title });
              }

              // ...

              &lt;input onChange={(e) => handleTitleChange(e.target.value) />
            }
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Action Creator...</h3>
          <ul>
            <li class="fragment">...sind "Factory-Funktionen", die Action-Objekte erzeugen</li>
            <li class="fragment">...sind optional, werden aber nahezu immer verwendet</li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function setDraftTitle(newTitle) {
              return { 
                type: "editor/setDraftTitle", 
                title 
              };
            }
            }
          </code></pre>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li class="fragment">
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li class="fragment">
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li class="fragment">
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li class="fragment">
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li class="fragment">Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li class="fragment">
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li class="fragment">
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
              function PostEditor() {
                const draftTitle = useSelector(state => state.editor.draftTitle);

                //  ...
              }
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Abgeleitete Daten</h3>
          <ul>
            <li class="fragment">Berechnungen etc.</li>
            <li class="fragment">
              Du kannst in useSelector auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur
              den von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store
              kommt oder basierend auf dem Store "berechnet" wurde
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function AppHeader() {
              // "abgeleiteter" Zustand
              const hasDraftPost = useSelector(
                state => state.editor.draftTitle !== "" || state.editor.draftBody !== ""
              );
            }

            // √ºbergebene Selector-Callback-Funktion 
            //    wird bei JEDER √Ñnderung des Stores ausgef√ºhrt
            // AppHeader wird nur neu gerendert, 
            //    wenn sich deren R√úCKGABEWERT √§ndert
          </code></pre>

          <ul>
            <li class="fragment">
              <a href="https://github.com/reduxjs/reselect">reselect</a> bietet Caching f√ºr
              berechnete Daten
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            import { createSelector } from 'reselect'
            
            const fullnameSelector = createSelector(
              state => state.person.firstname,  // input selector 1
              state => state.person.lastname, // input selector 2
              (firstname, lastname) => `${firstname} ${lastname}`
            )
            
          </code></pre>

          <ul>
            <li class="fragment">
              Nur wenn sich einer der "Input Selectors" √§ndert, wird die letzte Funktion ausgef√ºhrt
            </li>
            <li class="fragment">
              Der letzen Funktion werden die R√ºckgabewerte aller Selektoren √ºbergeben
            </li>
            <li class="fragment">Die letzte Funktion berechnet dann den eigentlichen Wert</li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function AppHeader() {
              const fullname = useSelector(fullnameSelector);

              return <h1>Good morning, {fullname}</h1>
            }
          </code></pre>

          <ul>
            <li class="fragment"></li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Dev Tools</h3>

          <p>
            Die Redux Dev Tools (Browser-Erweiterung) k√∂nnen in der Anwendung beim Konfiguration des
            Stores ein- oder ausgeschaltet werden
          </p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=de"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/reduxdevtools/" target="_blank"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <!--      
        <section>
          <h3>Redux</h3>
          <h2>Asynchrone Actions</h2>
          <p><em>Problem: Asynchronit√§t, z.B. beim Laden von Daten</em></p>
          <ul>
            <li class="fragment">
              Wo unterbringen?
              <ul>
                <li>Reducer sind Seiteneffekt-frei!</li>
                <li>Actions sind nur JavaScript-Objekte (keine Logik)!</li>
              </ul>
            </li>
            <li class="fragment">
              Weiteres Problem: fachliche Abl√§ufe meistens komplex(er) als nur eine Action.
              <ul>
                <li>
                  Typisch: Request Start, Request l√§uft, Request erfolgreich/Request fehlgeschlagen
                </li>
              </ul>
            </li>
            <li class="fragment">Redux bringt daf√ºr nix mit :-(</li>
            <li class="fragment">Es gibt aber Antworten: Thunk (Promi?), Saga, Observable</li>
          </ul>
        </section>
        <section>
          <h3>Redux</h3>
          <h2>Asynchrone Actions</h2>
          <em>Grunds√§tzliche Idee</em>
          <ul>
            <li class="fragment">
              Im <b>Action Creator</b> kann asynchroner Code ausgef√ºhrt werden
            </li>
            <li class="fragment">
              Es k√∂nnen <b>mehrere Actions</b> innerhalb des Action Creators dispatched werden
            </li>
            <li class="fragment">
              Alle genannten Bibliotheken werden √ºber die <b>Redux Middleware API</b> eingebunden, die eine Art "Plug-in"-System f√ºr Redux erm√∂glicht
            </li>
          </ul>
        </section>


        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>
            Schritt 1: <b>Dispatchen von Actions</b>: Komponente bleibt unver√§ndert, dispatched
            weiterhin eine Action, die wie eine "normale" Redux Action aussieht
          </p>
          <div class="fragment">
            <pre><code>
              import { loadPosts } from "./posts-slice";

              function App() {
                React.useEffect( 
                  () => dispatch(loadPosts()),
                  []
                );

                return ...;
            }
          </code></pre>
          </div>
        </section>
        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>
            Schritt 2: <b>Action Creator</b>: Hier k√∂nnen jetzt weitere Actions, auch asynchron,
            dispatched werden
          </p>
          <pre class="fragment"><code>
              // asynchroner Action Creator (pseudo code)
              function loadPosts() {

                dispatchAction "REQUEST_START"

                try {
                  posts = await loadPostsWithFetch() // ASYNCHRON !!!
                  dispatchAction "REQUEST_SUCCESS"
                  dispatchAction "SET_POSTS" posts
                } catch (err) {
                  dispatchAction "REQUEST_FAILURE" err
                }
              }
            </code></pre>
        </section>

        <section>
          <h3>Asynchrone Actions</h3>
          <em>Beispiel (konzeptionell)</em>
          <p>Schritt 3: <b>Reducer</b>: Unver√§ndert. Reducer empfangen "normale" Actions</p>
        </section>

        <section>
          <h2>Beispiele f√ºr Middlewares zum Arbeiten mit Asynchronit√§t</h2>
          <ul>
            <li>
              <a href="https://github.com/reduxjs/redux-thunk">Redux Thunk</a> (die "offizielle"
              L√∂sung)
            </li>

            <li>Redux Saga</li>
            <li>Redux Observable</li>
          </ul>
        </section>

        <section>
          <h2>Redux Thunk</h2>
          <ul>
            <li class="fragment">
              Ein Thunk Action Creator gibt kein Action-Objekt, sondern eine
              <b>Callback-Funktion</b> zur√ºck. Diese Funktion wird von Redux an die Middlewares
              weitergegeben. (Redux gibt nahezu alles, was wir dispatch √ºbergeben an die Middlewares
              bzw. den Store weiter...)
            </li>
            <li class="fragment">
              In der Callback-Funktion ist dann die (asynchrone) Logik untergebracht
            </li>
            <li class="fragment">
              Wenn die Thunk-Middleware eine Funktion entdeckt (und kein Objekt), ruft die
              Middleware diese Funktion auf, und √ºbergibt eine <code>dispatch</code>- und eine
              <code>getState</code>-Funktion
            </li>
            <li class="fragment">
              Mit <code>dispatch</code> kann die Callback-Funktion diverse weitere "regul√§re" und
              Thunk-Actions ausl√∂sen
            </li>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            export function loadPosts() {
              return (dispatch, getState) => {

                dispatch(postsLoading());

                fetch("http://localhost:7000/posts")
                  .then(response => response.json())
                  .then(json => {
                    dispatch(postLoadingSucceeded(json));
                  })
                  .catch(err => {
                    dispatch(postLoadingFailed(err));
                  });
              };
            }    </code></pre>
          </ul>
        </section>
        <section>
          <h2>Redux Thunk</h2>
          <p>Thunk Actions k√∂nnen nicht nur f√ºr asynchone Anwendungsf√§lle verwendet werden</p>
          <ul>
            <li class="fragment">
              F√ºr Anwendungsf√§lle in den allgemein mehr als eine Action dispatched werden soll
            </li>
            <li class="fragment">
              Es ist darin erlaubt, beliebige Seiteneffkte auszuf√ºhren, z.B. eine uuid generieren
              oder auf die Uhrzeit zuzugreifen
            </li>
            <li class="fragment">
              Im Gegensatz zum Reducer hat ein Action-Creator Zugriff auf den gesamten State und
              kann z.B. eine Cache-Funktionali√§t implementieren
            </li>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
            export function loadPostsWithCache() {
              return (dispatch, getState) => {

                if (getState().posts.posts) {
                  // Posts sind schon geladen => nicht erneut laden
                  return;
                }


                dispatch(postsLoading());

                // ...wie gesehen: Posts laden etc.
              };
            }    </code></pre>
          </ul>
        </section> -->

        <section id="redux-toolkit">
          <h3>Redux Toolkit</h3>
          <p>
            <em
              >"The official, opinionated, batteries-included toolset for efficient Redux
              development"</em
            >
          </p>
          <ul>
            <li><a href="https://redux-toolkit.js">https://redux-toolkit.js.org/</a></li>
            <li>
              Vorkonfiguriertes Setup (inklusive
              <a href="https://github.com/immerjs/immer">immer</a> f√ºr Reducer und Thunk Middleware)
            </li>
            <li>
              Vereinfacht erheblich das Arbeiten mit Reducer, generiert z.B. Action Creator zur
              Laufzeit
            </li>
            <li>Vereinfacht typische Anwendungsf√§lle wie API Calls</li>
            <li>
              Outstanding TypeScript support! Ihr wollt das nicht ohne TypeScript verwenden üòâ
            </li>

            <li class="fragment">
              Neu: <a href="https://rtk-query-docs.netlify.app/">RTK Query</a>: Data Fetching und
              Caching f√ºr Redux
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Toolkit Beispiel</h3>

          <p>üëâüëâ Beispiel: 20_redux_toolkit_workspace</p>
          <p>üëâüëâ editor-slice konvertieren, PostEditor anpassen</p>
        </section>

        <section>
          <h3>createSlice</h3>
          <ul>
            <li class="fragment">
              Ein "Slice" repr√§sentiert einen fachnlichen "Schnitt" in Eurer Anwendung
            </li>
            <li class="fragment">
              Ein Slice wird mit der Funktion <code>createSlice</code> erzeugt
            </li>
            <li class="fragment">Diese Funktion erwartet ein Konfigurationsobjekt</li>
            <li class="fragment">
              √úber dieses Objekt k√∂nnen reducer und der initiale Zustand festgelegt werden
            </li>
            <li class="fragment">
              F√ºr jede reducer-Funktion wird per Default ein action-creator automatisch generiert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              name: "hello",
              initalState: { name: "world" },
              reducers: {
                greet(state, action) {
                  // ...
                }
              }
            })
          </code></pre>

          <pre class="fragment"><code class="javascript">
            const dispatch = useDispatch();

            dispatch(hello.actions.greet({
              name: "World"
            }))
          </code></pre>
        </section>

        <section>
          <h3>reducer</h3>
          <ul>
            <li class="fragment">
              Wie gesehen, bekommen reducer den slice-State und die Action √ºbergeben
            </li>
            <li class="fragment">
              Die reducer-Funktionen werden mit <b>immer</b> umschlossen, so dass der State dort
              <b>mutable</b> ist (bzw so aussieht, als ob er mutable ist)
            </li>
            <li class="fragment">
              Der State kann deshalb direkt bearbeitet werden oder es kann ein komplett neues Objekt
              zur√ºckgegeben werden
            </li>
          </ul>
          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              // ...
              reducers: {
                greet(state, action) {
                  state.name = action.payload.name;
                },
                clear() {
                  return { name: "" };
                }
              }
            })
          </code></pre>
        </section>
        <section>
          <h3>reducer und Action Creator</h3>
          <ul>
            <li class="fragment">
              Zu jeder reducer-Funktion wird eine Action-Creator-Funktion erzeugt
            </li>
            <li class="fragment">
              Diese Funktion erwartet einen Parameter: den Action-Payload (oder gar nichts)
            </li>
            <li class="fragment">
              Die Funktionen liegen unterhalb von <code>sliceName.actions</code> und k√∂nnen von dort
              exportiert werden, so dass die Anwendung darauf Zugriff hat
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const hello = createSlice({
              // ...
              reducers: {
                
                greet(state, action) { ... },
                clear() { ... }
                }
              }
            })   
          
            export const { greet, clear } = hello.actions;
          
          </code></pre>

          <pre class="fragment"><code class="javascript">
            import { greet } from "./hello-slice";

            // in der Komponente
            dispatch(greet({name: "Klaus"}));

            // ohne payload
            dispatch(clear());
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### "Modernes" Redux

            * Grunds√§tzlich: Redux ist leichtgewichtiger geworden(?)
              * Hooks API
              * Toolkit mit immer- und TypeScript-Support und guter Vorkonfiguration
              * Spart beides viel Boilerplate
            * Sehr gute und ausf√ºhrliche Dokumentation   
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>

            ### Redux: wann einsetzen?
            * "Gro√üe" Anwendungen
              * mit vielen globalen Daten
              * mit viel Logik
            * Arbeiten mit mehreren Teams
              * Anwendung kann durch Actions/Reducer sehr gut getrennt entwickelt werden
            * Falls Redux, dann Redux Toolkit
          </textarea>
        </section>

        <section>
          <h3>Was nehme ich denn jetzt?</h3>
          <h3>Redux vs Context</h3>
          <p class="fragment">
            Redux hat Dev Tools, Time Travelling, Middlewares, globale Actions und Reducers/State
          </p>
          <p class="fragment">Redux ist sehr optimiert f√ºr Performance (h√§ufige Updates)</p>
          <p class="fragment">Context von der API her einfacher (aber auch nicht so m√§chtig)</p>
          <p class="fragment">
            Redux l√§sst feingranularere Auswahl aus dem globalen Zustand zu (verhindert unn√∂tige
            Renderings)
          </p>
        </section>

        <section>
          <h3>Redux vs Context</h3>
          <h3><em>Wie entscheiden wir uns?</em></h3>
          <p class="fragment">
            Entscheidung 1: Mischform: Redux <b>und</b> Context? Oder: Redux <b>oder</b> Context
          </p>
          <p class="fragment">Entscheidung 2: Was kommt wohin?</p>
          <p class="fragment">Auth-State (eingeloggter Benutzer)</p>
          <p class="fragment">Api-State: Netzwerk Request(s) laufen gerade</p>
          <p class="fragment">Draft-Post: editierters, neues, Post</p>
        </section>

        <!-- ============================================================================= -->
        <section id="t-mobx">
          <h2>MobX</h2>

          <p>
            Klassiker im <a href="https://michel.codes/blogs/mobx6">neuen Gewand</a> (Version 6 vom
            September 2020)
          </p>
        </section>

        <section>
          <h3>MobX</h3>
          <ul>
            <li class="fragment">
              <a href="https://mobx.js.org/README.html">https://mobx.js.org/README.html</a>
            </li>
            <li class="fragment">Claim: <b>Simple, scalable state management.</b></li>
            <li class="fragment">
              Aktuelle Version und Library f√ºr React:
              <a href="https://mobx.js.org/react-integration.html">mobx-react-lite</a>
            </li>
            <li class="fragment">
              Achtung #1: mobx-react braucht ihr nicht (wenn ihr Hooks API verwendet)
            </li>
            <li class="fragment">
              Achtung #2: Doku teilweise veraltet, die nicht direkt auf mobx.js.org liegt!
            </li>
            <li class="fragment">
              Basiert auf der Idee von "observable State", der von Euren Komponenten "observiert"
              wird
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX Schritt-f√ºr-Schritt</h3>

          <p>Hands-On üëâ <code>advanced/exercices/7a-mobx</code></p>
          <p>Fertig üëâ <code>advanced/steps/7a-mobx</code></p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX, Beispiel #1</h3>
          <ul>
            <li class="fragment">
              Der Zustand in MobX wird entweder in JavaScript-Objekten oder ES6-Klassen gehalten
            </li>
            <li class="fragment">
              Ihr k√∂nnt beides verwenden, ES6-Klassen weiter verbreitet und in der Doku auch
              empfohlen
            </li>
            <li class="fragment">Eine Klasse m√ºsst ihr zum "Observer" machen</li>
          </ul>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];

  constructor() {
    // Diese Instanz "observieren", MobX verfolgt jetzt alle √Ñnderungen
    makeAutoObservable(this);
  }
}        

// Unser globaler Zustand
const blogAppState = new blogAppState();  
        </code></pre>

          <ul>
            <li class="fragment">
              Eine Komponente kann zum Observer werden, und rendert sich dann bei allen √Ñnderungen
              an der beobachteten Klasse:
            </li>
          </ul>
          <pre class="fragment"><code class="javascript">
const PostList = observer(function PostList() {
  return &lt;div>
    {blogAppState.blogPosts.map( p => /* wie gewohnt */ )}
  &lt;/div>  
})
        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>MobX: Actions</h3>
          <ul>
            <li class="fragment">
              Der Zustand in MobX wird √ºber Actions ver√§ndert. Dabei handelt es sich um Methoden an
              einer Klasse.
            </li>
            <li class="fragment">
              Wenn der Zustand au√üerhalb einer Action ver√§ndert wird, gibt es einen Fehler. Auf
              diese Weise erzwingt MobX eine gewisse Architektur
            </li>
            <li class="fragment">
              Die Action-Methoden werden per Konvention von <code>makeAutoObservable</code> erkannt,
              oder ihr gebt sie explizit an
            </li>
            <li class="fragment">Das Laden von Daten k√∂nnte z.B. eine Action sein:</li>
          </ul>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];
            
  constructor() { makeAutoObservable(this); }

  async loadPosts() {
    const await response = fetch("...");
    const posts = await response.json();
    this.blogPosts = posts;
  }
}
          </code></pre>

          <pre class="fragment"><code class="javascript">
// Ausl√∂sen:
function App() {
  React.useEffect(  () => { blogState.loadPosts() }, []);

  // ...
}            
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Berechnete Werte: Computed Properties</h3>
          <ul>
            <li>
              MobX kann berechnete Werte cachen. Berechnete Werte basieren auf observierten Daten.
            </li>
            <li>
              Beispiel: Auf Basis der Blog-Post-Liste (beobachtet) und eines Sortierkriteriums
              (beobachtet) wird eine sortierte Blog-Post-Liste erzeugt. Die sortierte Liste ist ein
              "berechneter" Wert.
            </li>
            <li>
              Der Wert wird dann nur neuberechnet, wenn sich einer der darin verwendeten Werte
              √§ndert (Liste oder Kriterium).
            </li>
            <li>Ein Computed Property ist in der Regel eine getter-Methode an einer Klasse</li>
          </ul>
        </section>
        <section>
          <h3>Berechnete Werte #2</h3>
          <p>Beispiel</p>

          <pre class="fragment"><code class="javascript">
class BlogAppState = {
  blogPosts:Array&lt;BlogPost> = [];
  orderBy:string = "";
  currentUser: string = "";
            
  constructor() { makeAutoObservable(this); }

  get orderedPosts loadPosts() {
    const posts = [...blogPosts];
    posts.sort(orderBy); // vereinfacht

    return posts;
  }
}              
            </code></pre>

          <pre class="fragment"><code class="javascript">
blogAppState.orderedPosts; // Liste wird initial berechnet
blogAppState.orderedPosts; // Liste wird NICHT neu berechnet (Cache!)

blogAppState.orderBy = "date";              
blogAppState.orderedPosts; // Liste wird neu berechnet

blogAppState.currentUser = "Klaus";
blogAppState.orderedPosts; // Liste wird NICHT berechnet
            </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Observed Components</h3>

          <ul>
            <li class="fragment">
              Eine Komponente, die mit dem State arbeitet, muss ein Observer werden
            </li>
            <li class="fragment">
              Dazu wird sie der <code>observe</code>-Funktion √ºbergeben, die eine eine observed
              Komponente zur√ºckliefert
            </li>
            <li class="fragment">Das ist f√ºr den Aufrufer vollst√§ndig transparent</li>
            <li class="fragment">
              Die observed Komponente wird immer dann neu gerendert, wenn sich einer der Werte
              ver√§ndert, auf die sie zugreift
            </li>
            <li class="fragment">
              Die observed Komponente rendert sich daher auch nicht neu, wenn ihre Parent-Komponente
              sich neu rendert
            </li>
            <li class="fragment">Ausnahme: die Parent-Kompoenten √ºbergibt ver√§nderte Properties</li>
          </ul>
          <pre class="fragment"><code class="javascript">
            const PostList = observer(function PostList() {
              return &lt;div>
                {blogAppState.blogPosts.map( p => /* wie gewohnt */ )}
              &lt;/div>  
            })  
          </code></pre>
        </section>

        <section>
          <h3>Bereitstellen des Zustands</h3>

          <ul>
            <li>MobX ist es egal, wo der Zustand herkommt; es ist ein beliebiges Observable</li>
            <li>
              Typischerweise wird der Zustand in React-Anwendungen √ºber genau einen Context in die
              Anwendung gereicht
            </li>
            <li>
              Das Context-Objekt wird sich nie √§ndern, da sich nur die Werte in der Klasse
              ver√§ndern.
            </li>
            <li>
              Deswegen wird eine konsumierende Komponente auch nie neu gerendert, weil sich der
              Context nicht √§ndert
            </li>
            <li>
              Deswegen muss die Komponente ein Observer sein; wenn sich ein Wert aus dem Context
              √§ndert, rendert MobX neu
            </li>
          </ul>
        </section>
        <section>
          <h3>Bereitstellen des Zustands - Beispiel</h3>

          <pre class="fragment"><code class="javascript">
const context = {
  blog: new BlogAppState(),
  auth: new AuthenticationState()
}
function StoreProvider({ children }) {
  return (
    &lt;StoreContext.Provider value={context}>
      {children}
    &lt;/StoreContext.Provider>
  );
}

export function useStore() {
  return React.useContext(StoreContext);
}
          </code></pre>

          <pre class="fragment"><code class="javascript">
const PostList = observe(function PostList() {
  const { blog } = useStore();

  // PostList wird nur neu gerendert, wenn sich BlogPost-Liste √§ndert
  return blog.posts.map(&lt;BlogPost id={...});
})           
          </code></pre>
        </section>

        <section>
          <h3>MobX vs. Redux</h3>

          <ul>
            <li class="fragment">Redux eher funktionale Programmierung, MobX eher OO</li>
            <li class="fragment">Viel Freiheiten mit MobX...</li>
            <li class="fragment">...aber auch viel "Magie"</li>
            <li class="fragment">
              In gro√üen Modellen manchmal schwer zu verstehen, was eigentlich wo und wie "observed"
              wird
            </li>
            <li class="fragment">Observer-Komponenten eher untypisch f√ºr React (noch)</li>
            <li class="fragment">Developer Tooling nicht so gut wie Redux</li>
            <li class="fragment">Doku, StackOverflow etc. deutlich weniger umf√§nglich als Redux</li>

            <li class="fragment">
              Arbeiten mit asynchronen Daten in MobX "nat√ºrlicher", Thunk Actions sehr ungew√∂hnlich
            </li>

            <li class="fragment">
              Computed Properties in MobX sehr einfach, re-select gew√∂hnungsbed√ºrftig
            </li>

            <li class="fragment">üëâ Beide Bibliotheken gute Wahl und k√∂nnen verwendet werden</li>
            <li class="fragment">üëâ "F√ºr Redux ist noch niemand entlassen worden"</li>
          </ul>
        </section>

        <section data-markdown id="t-recoil">
          <textarea data-template>
            ## Recoil

            * https://recoiljs.org
            * Vor ca. einem Jahr vorgestellt
            * Von Facebook, aber nicht React-Team
            * Man definiert "Atome", das sind unabh√§ngige, globale Zust√§nde
            * Auf die Atome hat man lesend und schreibend Zugriff wie bei `useState`, aber aus allen Komponenten
          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Recoil</h3>

          <pre class="fragment"><code class="javascript">
          const itemsState = atom({
            key: 'shoppingListItems',
            default: [
              { name: "Book", 
                quantitiy: 1
              }
            ],
          });

          function App() {
            const [items, setItems] = useRecoilState(itemsState);

            // render list of items
          }
        </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Recoil: Selektoren</h3>

          <ul>
            <li class="fragment">Berechnete Daten werden √ºber Selektoren zur Verf√ºgung gestellt</li>

            <li class="fragment">
              Ein Selektor kann Atome bestimmten, von denen er abh√§ngi ist. Wenn eines der Atome
              sich √§ndert, wird der Wert des Selektors neu bestimmt:
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const itemsState = atom({ /* ... */ }); // wie gesehen
            const oderByState = atom({ key: "orderBy", default: "desc" });

            const orderedItemsSelector = selector({
              key: 'orderedItems',
              get: ({get}) => {
                const allItems = get(itemsState);
                const orderBy = get(orderByState);
               
                return ... /* allItems basierend auf orderBy sortieren */
              }
            });

            function OrderedList() {
              const orderedItems = useRecoilValue(orderedItemsSelector);

              // sortierte Liste rendern
            }
                        
          </code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Recoil: asynchrone Daten</h3>

          <ul>
            <li class="fragment">Atome und Selektoren k√∂nnen asynchron sein</li>

            <li class="fragment">
              Beispiel: ein asynchroner Selektor, der Daten l√§dt, sobald sich eine Id √§ndert
            </li>
          </ul>

          <pre class="fragment"><code class="javascript">
            const blogPostIdState = atom({ key: "blogPostId", default: null }); 
            const blogPostSelector = selector({
              key: "blogPost",
              get: async ({get}) => {
                const postId =  get(blogPostIdState)  // wenn sich Id √§ndert, wird Selector neu ausgef√ºhrt
                const data = await fetch(`/api/posts/${postId}).json(); // vereinfacht
                return data;
              },
            })
          </code></pre>

          <ul>
            <li class="fragment">Recoil arbeitet bereits mit React Suspense zusammen:</li>
          </ul>

          <pre class="fragment"><code class="javascript">
            function BlogPostPage() {
              const blogPost = useRecoilValue(blogPostSelector);

              return ...;
            }

            function App() {
              return   &lt;Suspense fallback={"Blog Post is loading"}>
                &lt;BlogPostPage />
              &lt;/Suspense>
            }
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Recoil: wann einsetzen

            * Anwendungen, mit vielen unabh√§ngigen Daten
              * Zum Beispiel Graphik-Programm, in dem die Eigenschaften der Objekte in Atomen gehalten werden
            * Anwendungen, in denen Daten mehr oder minder nur gesetzt und gelesen werden
              * ohne gr√∂√üere Logik
            * Vielleicht aktuell noch zu wenig verbreitet
              * Weitere Entwickung beobachten  
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ### Recoil vs. Redux/Mobx

            * Recoil noch sehr jung, interessantes Konzept
            * Selektoren √§hneln den computed Properties von MobX
            * Wo bringt man seine Gesch√§ftslogik unter?
              * MobX: Store-Klassen
              * Redux: Actions und Reducer
              * Recoil: Atome, aber:
              * Recoil m√∂glicherweise eher nur f√ºr Daten, weniger f√ºr Logik ("globales useState")
            * Recoil arbeitet mit Suspense und [Concurrent Rendering](https://recoiljs.org/blog/2020/09/15/0.0.11-released/#experimental-concurrent-mode-support) zusammen  
              * noch experimentell
              * f√ºr MobX und Redux noch unklar, technisch schwierig umzusetzen
            * Recoil in jedem Fall React-abh√§ngig, Kerne von MobX und Redux sind React-unabh√§ngig

          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Happy Statemanagement üåª</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich gerne kontaktieren:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
    <script>
      const isLocal =
        window.location.hostname.indexOf("localhost") !== -1 ||
        window.location.hostname.indexOf("127.0.0.1") !== -1 ||
        window.location.href.startsWith("file:///");
      Reveal.addEventListener("ready", function (event) {
        $("li").addClass("fragment");

        // make all links open in new tab
        $("a").attr("target", "_blank");

        if (isLocal) {
          // only applies to presentation version
          Reveal.configure({ controls: false });
        } else {
          // only applies to public version
          $(".fragment").removeClass("fragment");
        }
      });
    </script>
  </body>
</html>
